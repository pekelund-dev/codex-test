<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org" th:replace="~{layout :: layout(${pageTitle}, ~{::section})}">
<head>
    <title th:text="${pageTitle}">Receipt details</title>
</head>
<body>
<section class="py-3 py-lg-4">
    <div class="d-flex align-items-center gap-2 mb-3">
        <a class="btn btn-link p-0 text-decoration-none" th:href="@{/receipts(scope=${scopeParam})}">
            <i class="bi bi-arrow-left"></i>
            Back to receipts
        </a>
    </div>

    <div th:if="${canViewAll}" class="mb-3">
        <div class="btn-group btn-group-sm" role="group" aria-label="Receipt scope">
            <a class="btn btn-outline-primary" th:classappend="${scopeParam == 'my'} ? ' active'"
               th:href="${ownsReceipt} ? @{/receipts/{id}(id=${receipt.id()}, scope='my')} : @{/receipts(scope='my')}">My receipts</a>
            <a class="btn btn-outline-primary" th:classappend="${scopeParam == 'all'} ? ' active'"
               th:href="@{/receipts/{id}(id=${receipt.id()}, scope='all')}">All receipts</a>
        </div>
        <p class="text-muted small mb-0 mt-2"
           th:text="${viewingAll} ? 'Viewing all parsed receipts.' : 'Viewing only your parsed receipts.'">Viewing only your parsed receipts.</p>
    </div>

    <div class="card shadow-sm border-0">
        <div class="card-body p-4">
            <div class="d-flex flex-column flex-md-row justify-content-between align-items-md-start gap-3">
                <div>
                    <h1 class="h3 fw-semibold text-primary mb-1"
                        th:text="${receipt.displayName() != null ? receipt.displayName() : 'Receipt details'}">Receipt details</h1>
                    <p class="text-muted mb-0" th:if="${receipt.objectPath()}" th:text="${receipt.objectPath()}">gs://bucket/object</p>
                </div>
                <div class="d-flex flex-column align-items-md-end gap-2">
                    <span class="badge text-uppercase fw-semibold align-self-start align-self-md-end"
                          th:classappend="${receipt.statusBadgeClass()}"
                          th:text="${receipt.status() != null ? receipt.status() : 'UNKNOWN'}">COMPLETED</span>
                    <div class="fw-semibold text-secondary" th:if="${receipt.formattedTotalAmount()}">
                        Total:
                        <span th:text="${receipt.formattedTotalAmount()}">129.99</span>
                        <span class="text-muted">SEK</span>
                    </div>
                </div>
            </div>

            <div class="row mt-4 gy-3">
                <div class="col-md-6">
                    <dl class="row mb-0">
                        <dt class="col-sm-4">Store</dt>
                        <dd class="col-sm-8" th:text="${receipt.storeName() != null ? receipt.storeName() : '—'}">Store name</dd>
                        <dt class="col-sm-4">Receipt date</dt>
                        <dd class="col-sm-8" th:text="${receipt.receiptDate() != null ? receipt.receiptDate() : '—'}">2024-01-01</dd>
                        <dt class="col-sm-4">Total</dt>
                        <dd class="col-sm-8" th:text="${receipt.formattedTotalAmount() != null ? receipt.formattedTotalAmount() : (receipt.totalAmount() != null ? receipt.totalAmount() : '—')}">129.99</dd>
                        <dt class="col-sm-4">Format</dt>
                        <dd class="col-sm-8" th:text="${receipt.format() != null ? receipt.format() : '—'}">NEW_FORMAT</dd>
                    </dl>
                </div>
                <div class="col-md-6">
                    <dl class="row mb-0">
                        <dt class="col-sm-4">Updated</dt>
                        <dd class="col-sm-8"
                            th:text="${receipt.updatedAtZoned() != null ? #temporals.format(receipt.updatedAtZoned(), 'yyyy-MM-dd HH:mm:ss') : '—'}">
                            2024-01-01 10:30:00
                        </dd>
                        <dt class="col-sm-4">Status message</dt>
                        <dd class="col-sm-8" th:text="${receipt.statusMessage() != null ? receipt.statusMessage() : '—'}">Completed</dd>
                        <dt class="col-sm-4">Error</dt>
                        <dd class="col-sm-8" th:text="${receipt.error() != null ? receipt.error() : '—'}">—</dd>
                    </dl>
                </div>
            </div>
        </div>
    </div>

    <div class="card shadow-sm border-0 mt-4">
        <div class="card-body p-4">
            <h2 class="h5 fw-semibold mb-3">Items</h2>
            <div th:if="${#lists.isEmpty(receiptItems)}" class="text-muted">No items were detected.</div>
            <div th:if="${!#lists.isEmpty(receiptItems)}" class="table-responsive">
                <table class="table align-middle">
                    <thead class="table-light">
                    <tr>
                        <th scope="col">Name</th>
                        <th scope="col">Quantity</th>
                        <th scope="col">Unit price</th>
                        <th scope="col">Total price</th>
                        <th scope="col">Discounts</th>
                        <th scope="col" th:if="${categorizationEnabled}">Taggar</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr th:each="item, iterStat : ${receiptItems}">
                        <td th:with="itemName=${item['name'] != null ? #strings.trim(item['name']) : null},
                                       itemEan=${item['normalizedEan'] != null ? item['normalizedEan'] : null},
                                       historyCount=${item['historyCount'] != null ? item['historyCount'] : 0L}">
                            <a th:if="${itemEan != null and historyCount > 1}"
                               class="fw-semibold text-decoration-none"
                               th:href="@{/receipts/items/{eanCode}(eanCode=${itemEan}, sourceId=${receipt.id()}, scope=${scopeParam})}"
                               th:text="${itemName != null ? itemName : '—'}">Item name</a>
                            <span th:if="${!(itemEan != null and historyCount > 1)}"
                                  class="fw-semibold"
                                  th:text="${itemName != null ? itemName : '—'}">Item name</span>
                            <div class="text-muted small" th:if="${itemEan != null}" th:text="${'EAN: ' + itemEan}">EAN</div>
                        </td>
                        <td th:text="${item['displayQuantity'] != null ? item['displayQuantity'] : (item['quantity'] != null ? item['quantity'] : '—')}">—</td>
                        <td th:text="${item['displayUnitPrice'] != null ? item['displayUnitPrice'] : (item['unitPrice'] != null ? item['unitPrice'] : '—')}">—</td>
                        <td th:text="${item['displayTotalPrice'] != null ? item['displayTotalPrice'] : (item['totalPrice'] != null ? item['totalPrice'] : '—')}">—</td>
                        <td>
                            <ul class="list-unstyled mb-0"
                                th:if="${item['discounts'] != null and !#lists.isEmpty(item['discounts'])}">
                                <li th:each="discount : ${item['discounts']}"
                                    th:text="${(discount['description'] != null ? discount['description'] : 'Discount') + ' (' + (discount['amount'] != null ? discount['amount'] : '—') + ')'}">Discount</li>
                            </ul>
                            <span th:if="${item['discounts'] == null or #lists.isEmpty(item['discounts'])}" class="text-muted">—</span>
                        </td>
                        <td th:if="${categorizationEnabled}" 
                            th:with="itemIdentifier=${item['normalizedEan'] != null ? item['normalizedEan'] : iterStat.index},
                                     assignedCategory=${itemCategoryMap.get(itemIdentifier.toString())},
                                     assignedTags=${itemTagsMap.get(itemIdentifier.toString())},
                                     hasCategories=${!#maps.isEmpty(categoriesHierarchy)}">
                            <div class="d-flex flex-column gap-2">
                                <!-- Show warning if no categories are available -->
                                <div th:if="${!hasCategories && iterStat.index == 0}" class="alert alert-warning alert-sm mb-2 p-2">
                                    <small>
                                        <i class="bi bi-exclamation-triangle"></i>
                                        Inga kategorier tillgängliga. 
                                        <a href="#" id="initializeCategoriesLink" 
                                           onclick="event.preventDefault(); initializeCategories();">
                                            Klicka här för att initiera
                                        </a>
                                        <span id="initializeStatus" class="ms-2"></span>
                                    </small>
                                </div>
                                
                                <!-- Tags display with badges -->
                                <div class="tags-container" 
                                     th:data-receipt-id="${receipt.id()}"
                                     th:data-item-index="${#strings.toString(iterStat.index)}"
                                     th:data-item-ean="${item['normalizedEan']}">
                                    <!-- Display existing tags as colored badges -->
                                    <div class="d-flex flex-wrap gap-1 align-items-center">
                                        <!-- Assigned tags will be rendered here by JavaScript -->
                                        <span class="tag-badges-display" th:data-assigned-tags="${assignedTags != null ? #strings.listJoin(assignedTags, ',') : ''}">
                                            <!-- Tags will be populated by JavaScript -->
                                        </span>
                                        <!-- Add tag button - always visible -->
                                        <button class="btn btn-sm add-tag-badge-btn badge" 
                                                type="button"
                                                title="Lägg till taggar"
                                                style="padding: 0.35rem 0.5rem; font-size: 0.75rem; border: 1px dashed #6c757d; background: #f8f9fa; color: #6c757d; cursor: pointer;">
                                            <i class="bi bi-plus"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </td>
                    </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <div class="card shadow-sm border-0 mt-4">
        <div class="card-body p-4">
            <h2 class="h5 fw-semibold mb-3">VAT summary</h2>
            <div th:if="${#lists.isEmpty(receipt.vats())}" class="text-muted">No VAT information available.</div>
            <div th:if="${!#lists.isEmpty(receipt.vats())}" class="table-responsive">
                <table class="table align-middle">
                    <thead class="table-light">
                    <tr>
                        <th scope="col">Rate</th>
                        <th scope="col">Net amount</th>
                        <th scope="col">Tax amount</th>
                        <th scope="col">Gross amount</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr th:each="vat : ${receipt.vats()}">
                        <td th:text="${vat['rate'] != null ? vat['rate'] : '—'}">—</td>
                        <td th:text="${vat['netAmount'] != null ? vat['netAmount'] : '—'}">—</td>
                        <td th:text="${vat['taxAmount'] != null ? vat['taxAmount'] : '—'}">—</td>
                        <td th:text="${vat['grossAmount'] != null ? vat['grossAmount'] : '—'}">—</td>
                    </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <div class="card shadow-sm border-0 mt-4">
        <div class="card-body p-4">
            <h2 class="h5 fw-semibold mb-3" th:text="#{receipt.discount.summary.heading}">Discount summary</h2>
            
            <!-- General discounts details -->
            <div th:if="${!#lists.isEmpty(receipt.generalDiscounts())}" class="mb-3">
                <h3 class="h6 text-muted mb-2" th:text="#{receipt.discount.general.details}">General discounts</h3>
                <ul class="list-group list-group-flush">
                    <li class="list-group-item d-flex justify-content-between align-items-center" 
                        th:each="discount : ${receipt.generalDiscounts()}">
                        <span th:text="${discount['description'] != null ? discount['description'] : 'Discount'}">Discount description</span>
                        <span class="badge bg-success-subtle text-success" 
                              th:text="${discount['amount'] != null ? discount['amount'] + ' SEK' : '—'}">0.00 SEK</span>
                    </li>
                </ul>
            </div>
            
            <!-- Item-specific discounts details -->
            <div th:if="${receipt.itemDiscountTotal().compareTo(T(java.math.BigDecimal).ZERO) > 0}" class="mb-3">
                <h3 class="h6 text-muted mb-2" th:text="#{receipt.discount.item.details}">Item-specific discounts</h3>
                <ul class="list-group list-group-flush">
                    <th:block th:each="item : ${receipt.items()}">
                        <th:block th:if="${item['discounts'] != null and !#lists.isEmpty(item['discounts'])}">
                            <li class="list-group-item" th:each="discount, iterStat : ${item['discounts']}">
                                <div class="d-flex justify-content-between align-items-center">
                                    <div>
                                        <span th:text="${item['name'] != null ? item['name'] : 'Item'}">Item name</span>
                                        <span class="text-muted">—</span>
                                        <span class="text-muted" th:text="${discount['description'] != null ? discount['description'] : 'Discount'}">Discount description</span>
                                    </div>
                                    <span class="badge bg-success-subtle text-success"
                                          th:text="${discount['amount'] != null ? discount['amount'] + ' SEK' : '—'}">0.00 SEK</span>
                                </div>
                            </li>
                        </th:block>
                    </th:block>
                </ul>
            </div>
            
            <!-- Total summary -->
            <dl class="row mb-0 mt-3 pt-3 border-top">
                <dt class="col-sm-6" th:text="#{receipt.discount.general.total}">General discounts total</dt>
                <dd class="col-sm-6 text-end" th:text="${receipt.formattedGeneralDiscount()} + ' SEK'">0.00 SEK</dd>
                
                <dt class="col-sm-6" th:text="#{receipt.discount.item.total}">Item-specific discounts total</dt>
                <dd class="col-sm-6 text-end" th:text="${receipt.formattedItemDiscount()} + ' SEK'">0.00 SEK</dd>
                
                <dt class="col-sm-6 fw-bold" th:text="#{receipt.discount.total.savings}">Total savings</dt>
                <dd class="col-sm-6 text-end fw-bold text-success" th:text="${receipt.formattedTotalDiscount()} + ' SEK'">0.00 SEK</dd>
            </dl>
        </div>
    </div>

    <div class="card shadow-sm border-0 mt-4">
        <div class="card-body p-4">
            <h2 class="h5 fw-semibold mb-3">Parsing errors</h2>
            <div th:if="${#lists.isEmpty(receipt.errors())}" class="text-muted">No parsing errors were reported.</div>
            <div th:if="${!#lists.isEmpty(receipt.errors())}" class="table-responsive">
                <table class="table align-middle">
                    <thead class="table-light">
                    <tr>
                        <th scope="col">Line</th>
                        <th scope="col">Content</th>
                        <th scope="col">Message</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr th:each="error : ${receipt.errors()}">
                        <td th:text="${error['lineNumber'] != null ? error['lineNumber'] : '—'}">—</td>
                        <td th:text="${error['content'] != null ? error['content'] : '—'}">—</td>
                        <td th:text="${error['message'] != null ? error['message'] : '—'}">—</td>
                    </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <div class="card shadow-sm border-0 mt-4">
        <div class="card-body p-4">
            <h2 class="h5 fw-semibold mb-3">Raw receipt text</h2>
            <pre class="bg-light p-3 rounded small" th:text="${receipt.rawText() != null ? receipt.rawText() : 'No raw text available.'}">No raw text available.</pre>

            <details class="mt-3">
                <summary class="fw-semibold text-primary">View raw response</summary>
                <pre class="bg-light p-3 rounded small mt-2"
                     th:text="${receipt.rawResponse() != null ? receipt.rawResponse() : 'No raw response available.'}">Raw response</pre>
            </details>
        </div>
    </div>
    
    <!-- Toast Container for notifications -->
    <div th:if="${categorizationEnabled}" class="toast-container position-fixed bottom-0 end-0 p-3" style="z-index: 1100;">
        <div id="notificationToast" class="toast" role="alert" aria-live="assertive" aria-atomic="true">
            <div class="toast-header">
                <i class="bi me-2" id="toastIcon"></i>
                <strong class="me-auto" id="toastTitle">Meddelande</strong>
                <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Stäng"></button>
            </div>
            <div class="toast-body" id="toastMessage">
                Meddelande kommer här
            </div>
        </div>
    </div>
    
    <!-- Tag Management Modal -->
    <div th:if="${categorizationEnabled}" class="modal fade" id="tagModal" tabindex="-1" aria-labelledby="tagModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="tagModalLabel">Hantera taggar</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Stäng"></button>
                </div>
                <div class="modal-body">
                    <!-- Selected tags preview -->
                    <div class="mb-3">
                        <label class="form-label fw-semibold small">Valda taggar:</label>
                        <div id="selectedTagsPreview" class="d-flex flex-wrap gap-1 p-2 border rounded bg-light" style="min-height: 2.5rem;">
                            <span class="text-muted small" id="noTagsSelected">Inga taggar valda</span>
                        </div>
                    </div>
                    
                    <!-- Available tags -->
                    <div class="mb-3">
                        <label class="form-label fw-semibold small">Tillgängliga taggar:</label>
                        <div id="availableTagsList" class="border rounded p-2" style="max-height: 200px; overflow-y: auto;">
                            <!-- Tags will be populated by JavaScript -->
                        </div>
                    </div>
                    
                    <!-- Create new tag -->
                    <div class="mb-3">
                        <label class="form-label fw-semibold small">Skapa ny tagg:</label>
                        <div class="input-group input-group-sm">
                            <input type="text" class="form-control" id="newTagName" placeholder="Taggnamn..." maxlength="50">
                            <button class="btn btn-outline-primary" type="button" id="createNewTagBtn">
                                <i class="bi bi-plus-circle"></i> Skapa
                            </button>
                        </div>
                        <div class="form-text small">Taggen får automatiskt en färg</div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary btn-sm" data-bs-dismiss="modal">Avbryt</button>
                    <button type="button" class="btn btn-primary btn-sm" id="saveTagsBtn">Spara ändringar</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Category and Tag Management JavaScript -->
    <script th:if="${categorizationEnabled}" th:inline="javascript">
        /*<![CDATA[*/
        document.addEventListener('DOMContentLoaded', function() {
            // Get all available tags from the server
            const allTags = /*[[${tags}]]*/ [];
            
            // Toast notification function
            function showToast(title, message, type = 'info') {
                const toastEl = document.getElementById('notificationToast');
                const toastIcon = document.getElementById('toastIcon');
                const toastTitle = document.getElementById('toastTitle');
                const toastMessage = document.getElementById('toastMessage');
                const toastHeader = toastEl.querySelector('.toast-header');
                
                // Reset classes
                toastHeader.className = 'toast-header';
                toastIcon.className = 'bi me-2';
                
                // Set icon and styling based on type
                if (type === 'success') {
                    toastIcon.classList.add('bi-check-circle-fill', 'text-success');
                    toastHeader.classList.add('bg-success', 'text-white');
                } else if (type === 'error') {
                    toastIcon.classList.add('bi-exclamation-circle-fill', 'text-danger');
                    toastHeader.classList.add('bg-danger', 'text-white');
                } else if (type === 'warning') {
                    toastIcon.classList.add('bi-exclamation-triangle-fill', 'text-warning');
                    toastHeader.classList.add('bg-warning', 'text-dark');
                } else {
                    toastIcon.classList.add('bi-info-circle-fill', 'text-info');
                    toastHeader.classList.add('bg-info', 'text-white');
                }
                
                toastTitle.textContent = title;
                toastMessage.textContent = message;
                
                const toast = new bootstrap.Toast(toastEl, { autohide: true, delay: 3000 });
                toast.show();
            }
            
            // Tag color palette (8 distinct colors)
            const tagColors = [
                '#0d6efd', // blue
                '#198754', // green
                '#dc3545', // red
                '#ffc107', // yellow
                '#0dcaf0', // cyan
                '#6f42c1', // purple
                '#fd7e14', // orange
                '#d63384'  // pink
            ];
            
            // Function to get color for a tag
            function getTagColor(tagId) {
                // Use tag ID hash to consistently assign colors
                let hash = 0;
                for (let i = 0; i < tagId.length; i++) {
                    hash = ((hash << 5) - hash) + tagId.charCodeAt(i);
                    hash = hash & hash;
                }
                return tagColors[Math.abs(hash) % tagColors.length];
            }
            
            // Function to create a badge element
            function createTagBadge(tag, showRemove = false, onClick = null) {
                const color = getTagColor(tag.id);
                const badge = document.createElement('span');
                badge.className = 'badge';
                badge.style.backgroundColor = color;
                badge.style.color = '#fff';
                badge.style.fontSize = '0.75rem';
                badge.style.padding = '0.35rem 0.5rem';
                badge.style.marginRight = '0.25rem';
                badge.style.display = 'inline-flex';
                badge.style.alignItems = 'center';
                badge.style.gap = '0.25rem';
                badge.style.cursor = onClick ? 'pointer' : 'default';
                
                const textSpan = document.createElement('span');
                textSpan.textContent = tag.name;
                badge.appendChild(textSpan);
                
                if (showRemove) {
                    const removeBtn = document.createElement('button');
                    removeBtn.type = 'button';
                    removeBtn.className = 'btn-close btn-close-white';
                    removeBtn.style.fontSize = '0.5rem';
                    removeBtn.style.padding = '0';
                    removeBtn.style.width = '0.75rem';
                    removeBtn.style.height = '0.75rem';
                    removeBtn.onclick = (e) => {
                        e.stopPropagation();
                        if (onClick) onClick(tag);
                    };
                    badge.appendChild(removeBtn);
                }
                
                if (onClick && !showRemove) {
                    badge.onclick = () => onClick(tag);
                }
                
                return badge;
            }
            
            // Function to render tags for an item
            function renderItemTags(container, assignedTagIds) {
                const badgesDisplay = container.querySelector('.tag-badges-display');
                badgesDisplay.innerHTML = '';
                
                if (!assignedTagIds || assignedTagIds.length === 0) {
                    return;
                }
                
                assignedTagIds.forEach(tagId => {
                    const tag = allTags.find(t => t.id === tagId);
                    if (tag) {
                        const badge = createTagBadge(tag, true, (removedTag) => {
                            removeTagFromItem(container, removedTag.id);
                        });
                        badgesDisplay.appendChild(badge);
                    }
                });
            }
            
            // Initialize tag displays
            document.querySelectorAll('.tags-container').forEach(container => {
                const badgesDisplay = container.querySelector('.tag-badges-display');
                const assignedTagsStr = badgesDisplay.dataset.assignedTags;
                const assignedTags = assignedTagsStr ? assignedTagsStr.split(',').filter(id => id) : [];
                renderItemTags(container, assignedTags);
            });
            
            // Modal state
            let currentTagModal = null;
            let selectedTagIds = [];
            
            // Handle add tag badge button clicks
            document.querySelectorAll('.add-tag-badge-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const container = this.closest('.tags-container');
                    const receiptId = container.dataset.receiptId;
                    const itemIndex = container.dataset.itemIndex;
                    const itemEan = container.dataset.itemEan;
                    
                    // Get currently assigned tags
                    const badgesDisplay = container.querySelector('.tag-badges-display');
                    const assignedTagsStr = badgesDisplay.dataset.assignedTags;
                    selectedTagIds = assignedTagsStr ? assignedTagsStr.split(',').filter(id => id) : [];
                    
                    // Store current context
                    currentTagModal = {
                        container: container,
                        receiptId: receiptId,
                        itemIndex: itemIndex,
                        itemEan: itemEan
                    };
                    
                    // Populate modal
                    populateTagModal();
                    
                    // Show modal
                    const modal = new bootstrap.Modal(document.getElementById('tagModal'));
                    modal.show();
                });
            });
            
            // Populate tag modal
            function populateTagModal() {
                const availableList = document.getElementById('availableTagsList');
                availableList.innerHTML = '';
                
                allTags.forEach(tag => {
                    const div = document.createElement('div');
                    div.className = 'form-check mb-2';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'form-check-input';
                    checkbox.id = 'tag-check-' + tag.id;
                    checkbox.value = tag.id;
                    checkbox.checked = selectedTagIds.includes(tag.id);
                    checkbox.onchange = () => updateSelectedTags();
                    
                    const label = document.createElement('label');
                    label.className = 'form-check-label d-flex align-items-center';
                    label.htmlFor = 'tag-check-' + tag.id;
                    
                    const badge = createTagBadge(tag, false);
                    label.appendChild(badge);
                    
                    div.appendChild(checkbox);
                    div.appendChild(label);
                    availableList.appendChild(div);
                });
                
                updateSelectedTagsPreview();
            }
            
            // Update selected tags based on checkboxes
            function updateSelectedTags() {
                const checkboxes = document.querySelectorAll('#availableTagsList input[type="checkbox"]');
                selectedTagIds = Array.from(checkboxes)
                    .filter(cb => cb.checked)
                    .map(cb => cb.value);
                updateSelectedTagsPreview();
            }
            
            // Update the preview of selected tags in modal
            function updateSelectedTagsPreview() {
                const preview = document.getElementById('selectedTagsPreview');
                const noTagsMsg = document.getElementById('noTagsSelected');
                
                preview.innerHTML = '';
                
                if (selectedTagIds.length === 0) {
                    if (noTagsMsg) {
                        const msg = noTagsMsg.cloneNode(true);
                        preview.appendChild(msg);
                    }
                } else {
                    selectedTagIds.forEach(tagId => {
                        const tag = allTags.find(t => t.id === tagId);
                        if (tag) {
                            const badge = createTagBadge(tag, false);
                            preview.appendChild(badge);
                        }
                    });
                }
            }
            
            // Handle create new tag in modal
            document.getElementById('createNewTagBtn').addEventListener('click', function() {
                const input = document.getElementById('newTagName');
                const tagName = input.value.trim();
                
                if (!tagName) {
                    showToast('Fel', 'Ange ett taggnamn', 'warning');
                    return;
                }
                
                fetch('/api/categorization/tags', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-TOKEN': getCsrfToken()
                    },
                    body: JSON.stringify({ name: tagName })
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('HTTP error! status: ' + response.status);
                    }
                    return response.json();
                })
                .then(tag => {
                    // Add to allTags array
                    allTags.push(tag);
                    // Add to selected
                    selectedTagIds.push(tag.id);
                    // Refresh modal
                    populateTagModal();
                    // Clear input
                    input.value = '';
                    // Show success message
                    showToast('Framgång', 'Tagg "' + tag.name + '" skapad', 'success');
                })
                .catch(err => {
                    console.error('Failed to create tag:', err);
                    showToast('Fel', 'Kunde inte skapa tagg. Försök igen.', 'error');
                });
            });
            
            // Handle save tags button
            document.getElementById('saveTagsBtn').addEventListener('click', function() {
                if (!currentTagModal) return;
                
                const { container, receiptId, itemIndex, itemEan } = currentTagModal;
                const badgesDisplay = container.querySelector('.tag-badges-display');
                const oldTagIds = badgesDisplay.dataset.assignedTags ? 
                    badgesDisplay.dataset.assignedTags.split(',').filter(id => id) : [];
                
                // Determine which tags to add and remove
                const tagsToAdd = selectedTagIds.filter(id => !oldTagIds.includes(id));
                const tagsToRemove = oldTagIds.filter(id => !selectedTagIds.includes(id));
                
                // Remove tags
                const removePromises = tagsToRemove.map(tagId => 
                    fetch(`/api/categorization/receipts/${receiptId}/items/tags/${tagId}?itemIdentifier=${itemEan || itemIndex}`, {
                        method: 'DELETE',
                        headers: { 'X-CSRF-TOKEN': getCsrfToken() }
                    })
                );
                
                // Add tags
                const addPromises = tagsToAdd.map(tagId =>
                    fetch(`/api/categorization/receipts/${receiptId}/items/tags`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRF-TOKEN': getCsrfToken()
                        },
                        body: JSON.stringify({
                            itemIndex: String(itemIndex),  // Ensure it's a string
                            itemEan: (itemEan && itemEan !== 'undefined') ? itemEan : null,  // Send null if empty or undefined
                            tagId: tagId
                        })
                    }).then(response => {
                        if (!response.ok) {
                            return response.text().then(text => {
                                throw new Error(`HTTP ${response.status}: ${text}`);
                            });
                        }
                        return response;
                    })
                );
                
                Promise.all([...removePromises, ...addPromises])
                    .then(() => {
                        // Update the display
                        badgesDisplay.dataset.assignedTags = selectedTagIds.join(',');
                        renderItemTags(container, selectedTagIds);
                        
                        // Show success message
                        showToast('Framgång', 'Taggar uppdaterade', 'success');
                        
                        // Close modal
                        bootstrap.Modal.getInstance(document.getElementById('tagModal')).hide();
                    })
                    .catch(err => {
                        console.error('Failed to update tags:', err);
                        showToast('Fel', 'Kunde inte uppdatera taggar: ' + err.message, 'error');
                    });
            });
            
            // Function to remove tag from item
            function removeTagFromItem(container, tagId) {
                const receiptId = container.dataset.receiptId;
                const itemIndex = container.dataset.itemIndex;
                const itemEan = container.dataset.itemEan;
                const itemIdentifier = itemEan || itemIndex;
                
                fetch(`/api/categorization/receipts/${receiptId}/items/tags/${tagId}?itemIdentifier=${itemIdentifier}`, {
                    method: 'DELETE',
                    headers: { 'X-CSRF-TOKEN': getCsrfToken() }
                })
                .then(() => {
                    // Update the display
                    const badgesDisplay = container.querySelector('.tag-badges-display');
                    const currentTags = badgesDisplay.dataset.assignedTags ? 
                        badgesDisplay.dataset.assignedTags.split(',').filter(id => id) : [];
                    const updatedTags = currentTags.filter(id => id !== tagId);
                    badgesDisplay.dataset.assignedTags = updatedTags.join(',');
                    renderItemTags(container, updatedTags);
                })
                .catch(err => console.error('Failed to remove tag:', err));
            }
            
            function getCsrfToken() {
                const meta = document.querySelector('meta[name="_csrf"]');
                return meta ? meta.getAttribute('content') : '';
            }
        });
        
        // Function to initialize categories (outside DOMContentLoaded so it's globally accessible)
        function initializeCategories() {
            const statusSpan = document.getElementById('initializeStatus');
            const link = document.getElementById('initializeCategoriesLink');
            
            if (link) {
                link.style.pointerEvents = 'none';
                link.style.opacity = '0.6';
            }
            
            if (statusSpan) {
                statusSpan.innerHTML = '<span class="spinner-border spinner-border-sm" role="status"></span> Initierar...';
            }
            
            const csrfToken = document.querySelector('meta[name="_csrf"]')?.content || '';
            
            fetch('/api/admin/categorization/initialize', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-TOKEN': csrfToken
                }
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('HTTP error! status: ' + response.status);
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    if (statusSpan) {
                        statusSpan.innerHTML = '<i class="bi bi-check-circle text-success"></i> Klart!';
                    }
                    setTimeout(() => location.reload(), 1000);
                } else {
                    if (statusSpan) {
                        statusSpan.innerHTML = '<i class="bi bi-exclamation-circle text-danger"></i> Fel: ' + (data.message || 'Okänt fel');
                    }
                    if (link) {
                        link.style.pointerEvents = 'auto';
                        link.style.opacity = '1';
                    }
                }
            })
            .catch(error => {
                console.error('Failed to initialize categories:', error);
                if (statusSpan) {
                    statusSpan.innerHTML = '<i class="bi bi-exclamation-circle text-danger"></i> Fel: ' + error.message;
                }
                if (link) {
                    link.style.pointerEvents = 'auto';
                    link.style.opacity = '1';
                }
            });
        }
        /*]]>*/
    </script>
</section>
</body>
</html>
